=head1 Day X

Layout of a Catalyst Application

=head2 catalyst.pl MyApp

When you run the catalyst helper as above, it creates quite a lot of
files which provide you a skeleton application.  It does this with the
help of the L<Template> Toolkit. The skeleton application provides a
single "Hello World" screen which is what you get regardless of what
url you visit.

The base application is created with the L<Catalyst::Helper> package,
which can be sub classed to provide more sophisticated code
generators.  L<Catalyst::Example::InstantCRUD> (a generator of
traditional form based database applications) provides an extension
to the base helper with L<Catalyst::Helper::InstantCRUD>.

Below we outline the basic anatomy of a Catalyst application, and
explain what the files and directories are for.

=head2 The Makefile.PL

Location: MyApp/Makefile.PL

It might not look important, but you should never remove this file
from your applications base directory. Catalyst needs it to
automatically it's location on your computer's file system.  As well
as this, it is the required in order to build a distribution (e.g. for
uploading to L<CPAN>), a L<PAR> package or just to simply collect your
applications dependencies. Catalyst uses L<Module::Install> for
Makefile and installation handling. If you'd like to add, for example,
a dependency on the  current version of L<DBIx::Class>, you'd add

  requires 'DBIx::Class' => '0.07003';

to it. This will alert you of a missing module or wrong version when
you run C<perl Makefile.PL>.

=head2 The Tests

  Location: MyApp/t

This is the location to put your application's tests into. CPAN has
a rich set of library to assist you in creating live and unit tests:

Usually, Perl tests have the format C<00-name.t>, where the C<00> is
a number that shows the order of the tests, and C<name> being the
topic of the test file. You're not forced to do it this way, of
course. Personally, I sometimes use three digits instead of two, the
first being an indicator on what will be tested. As an example:

  203-schema_category.t

Where the C<2> prefixes all tests for my DBIx-Class schema classes,
and the C<03> being the running number showing their order. There are
several ways to run tests, and a wide choice of tools which can be
used.  When installing a L<CPAN> module manually, usually we use the
following approach:

  perl Makefile.PL      # This creates the Makefile and test for
                        # your applications dependencies, if you
                        # specified them in it.
  make                  # Prepares your application for the other
                        # uses of 'make'. For example 'make install'
  make test             # Runs your distributions test suite.

You don't need to do all of that to run your tests, of course.
Especially during development, you can simply run your test suite
by using C<prove>:

  prove -l t/*.t

As you might see, this allows a far more fine grained control on
what parts of the test suites to run. Taking the example from above,
This would run the schema test files:

  prove -l t/2*.t

The C<prove> command line utility is part of the C<Test-Harness>
distribution, which you should find shipped with your Perl 5
distribution. You might want to read up it's manpage for all of it's
possibilities.

But let's say you want details on one single test file. Nothings
easier than that, since every C<.t> file is just a perl script:

  perl -Ilib t/203-schema_category.t

Will show you details on every test in the file. If you have taken
out the C<-Debug> flag of your application, but want to see its
debug output during this run, use the C<CATALYST_DEBUG> environment
variable:

  CATALYST_DEBUG=1 perl -Ilib t/203-schema_category.t

If you want to run your tests through the perl
debugger (i.e. C<perl -d> ) you can use the C<pler> utility which is
part of the L<Devel::Pler> package available from L<CPAN>.

=head2 The root

  Location: MyApp/root

This is the place for non-perl files. By default, some nice graphics
and logos shipped with Catalyst are included. However it's usually
also the place for all templates, and static files. Due to Catalysts
advanced configurability, the layout of this directory can be changed
completely to fit your needs.

=head2 The Configuration File

  Location: MyApp/myapp.yml

By default, C<catalyst.pl> will create a C<YAML> configuration file
for you. But you're not limited to that. At the time of writing this
article, C<Catalyst::Plugin::ConfigLoader> supports L<YAML>, JSON,
XML, INI, raw Perl and L<Config::General> (apache-like) file
formats. The configuration file gives you control over any of your
components C<config> options. For example the L<YAML> snippet below
sets C<.tt2> as the default template extension for a view class called
C<MyApp::View::TT>.

  # myapp.yml
  # ...
  View::TT:
      TEMPLATE_EXTENSION: ".tt2"

=head2 The Perl Modules

  Location: MyApp/lib

This is were the code for your application actually lives. After
creating a new Catalyst project, you will have this initial setup of
Perl modules:

=head3 The Application Class

  Location: MyApp/lib/MyApp.pm

This is were you specify which plugins to load, and where you can
implement methods which will be available through your context object
(C<$c>, as it's usually called). Note however, that it is recommended
to use controller base classes if you don't need access to Catalyt's
start up or request cycle.

=head3 The MVC Directories

  Locations: MyApp/lib/MyApp/Controller
             MyApp/lib/MyApp/Model
             MyApp/lib/MyApp/View

Catalyst follows the Model View Controller principle of application
design. Therefore these directories are provided by default, as almost
everyone will need them. You can also add auxilliary modules here as
well (which might work independently of the Catalyst application).  For example  C<MyApp/Schema/*> or C<MyApp/Base/Controller>.

=head3 The Root Controller

  Location: MyApp/lib/Controller/Root.pm

Most application will want to do something when your root index (C</>)
is requested. The place for those actions is the root controller.
Typical examples are a default handler for 404 pages

  sub default : Private {
    my ($self, $c) = @_;
    $c->response->body("404 - File Not Found");
    $c->response->status(404);
  }

and the index action:

  sub index : Private {
    my ($self, $c) = @_;
    # ...
    # code for application root
    # ...
  }

=head2 The Scripts

  Location: MyApp/script

These are used to run your application. But note that there are other
ways too, depending on the Catalyst engine you want to use.  In
particular L<mod_perl> and L<POE> engines don't need a script to run.

=head3 The Creation Helper Script

This is simply used to create new components in your application, if 
they provide helpers. You might want to look up their documentation to
find out if they do, and what arguments they take. Here are some examples:

  script/myapp_create.pl controller Foo::Bar

creates a C<MyApp::Controller::Foo::Bar> module in 
C<lib/MyApp/Controller/Foo/Bar.pm>. Another common thing might be a
view:

  script/myapp_create.pl view TT TT

for a C<MyApp::View::TT> (see L<Catalyst::View::TT> for details).

=head3 The Development Server

During your applications development phase, it is not needed to
actually deploy your application to a standalone web server for
testing.  mod_perl, FastCGI or something else to test it.  This is
thanks to Catalyst being engine agnostic. The line

  script/myapp_server.pl -d -p 2050 -r

Would run your application in debugging mode with proper output (C<-d>)
on port 2050 (C<-p 2050>) and restart if one of your components changes
(C<-r>).

=head3 Running a Test Request

This simple script does nothing more than start up your app, make a 
request, and print it's body to STDOUT. For example:

  script/myapp_test.pl /foo/bar

would show you the output of the C</foo/bar> action.

=head3 The Engine Scripts

Finally there are C<myapp_cgi.pl> and C<myapp_fastcgi.pl>.  While
Catalyst will run under plain CGI, this is not recommended as the
application has to start afresh for every request, and thus will be very
slow.  However this script can be used in persistent environments like
L<CGI::SpeedyCGI>.  The FastCGI script is for use with the L<FastCGI>
or L<fcgid|http://fastcgi.coremail.cn/> persistent environments.
Please note that at present, L<FastCGI> is the most common deployment
route for Catalyst applications.

=head2 Wrap up

So that's what happens when you type C<catalyst.pl> at the command
line.  We hope that this article means that Catalyst users can
understand the structure of their application a bit better now.  While
it may seem daunting at first, the architecture of a Catalyst
application is simple and intuitive.

=head3 AUTHORS

Robert 'phaylon' Sedlacek C<E<lt>rs@474.atE<gt>>
Kieren Diment C<E<lt>diment@gmail.comE<gt>>

=head3 COPYRIGHT.

Copyright 2006 Robert Sedlacek.  This document can be modified and
re-distributed under the same conditions as Perl itself.

