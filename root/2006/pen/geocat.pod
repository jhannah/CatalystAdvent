=head1 Day MCXIIV - Creating a Google Maps Mashup

Create a Catalyst Application that queries Google Maps Service

=head2 Google Maps Mashups

Since Google Maps was made public in July of 2005, hundreds of sites have joined
up in combining the mapping API with innovative and helpful applications.  Many
people are always wondering just how to get the maps on their sites, and this
is a good method on how to do so with Catalyst.

Any mapping application actually has two parts to managing the data:

=over 4

=item Geocoding

Geocoding is the process of turning a human readable address ("1600 Pennsylvania
Ave Washington DC") into a coordinate pair to dispaly on the map.  We'll cover
this by using L<Catalyst::Model::Geocode>.

=item Map Display

There are several mapping APIs to choose from, the three most popular are:

=over 2

=item Google Maps

Google Maps is probably the most popular mapping solution out.  It incorporates
a well-featured JavaScript API and is a combination of JavaScript and image
tiles.  We'll be using this, since it has the simplest APIs available.

=item Yahoo Maps

Yahoo Maps is another very popular mapping service that relies on Flash to
display the map, and comes with a JavaScript API to customize.

=item Microsoft Live

Microsoft Live's mapping service 

=back

=back

=head2 Application Overview

Our application will simply display a Google Map, run geocoding queries through
Catalyst, and run local queries through a JS engine.  The purpose of this 
application is to show how to structure an application that has both client
data requests (Google Local), and server requests (Geocoding).

It is a good combination of Chained actions and static content.

=head2 Getting Started

The first step for this application is the same with any Catalyst application,
and that is to allow Catalyst to setup the application structure:

    catalyst.pl GeoCat

To access Google's services (the mapping API and the geocoding API) you must
register your application with Google.  It's very simple to do so, just
visit L<http://www.google.com/apis/maps/signup.html> to get an
API key, and for the sake of this example we'll use the key provided for an
application at "localhost".  The key for localhost is:
 
 ABQIAAAAh3LqwY1XU3ldEkDJBxe4hBT2yXp_ZAY8_ufC3CFXhHIE1NvwkxTz_vK_MxtAQetI990enKf6YEthTA

To get access to this in our application, we'll put it in our applications
configuration (currently in L<YAML> format, but in the future Catalyst will use
L<Config::General> by default).  To keep it simple, we'll simply create a 
config key called "google" and stick the api key in.

Open up the C<GeoCat/geocat.yml> file, and it should look like this:

    ---
    name: GeoCat
    google:
        # This key is good only for http://localhost/
        key: "ABQIAAAAh3LqwY1XU3ldEkDJBxe4hBT2yXp_ZAY8_ufC3CFXhHIE1NvwkxTz_vK_MxtAQetI990enKf6YEthTA"

Once that is completed, it is time to install all the necessary bits.  First up
is making sure you have Miyagawa's L<Geo::Coder::Google> module:

    cpan Geo::Coder::Google 

Then it is time to create the necessary models and controllers for our
application.  Catalyst creates the Root controller for us, but we'll need to
create an additional controller to handle searching, and a model for it to go
along with.

    script/geocat_create.pl controller Search
    script/geocat_create.pl model Geocode

And the view (just to make sure it is installed):
    
    script/geocat_create.pl view TT TT

=head2 Setting the default actions

We're using the Chained Dispatch type (L<Catalyst::DispatchType::Chained>) for
our application, which has a different structure than what is typically used but
is definitely the way forward for Catalyst applications.  The first step is
to tell Catalyst exactly where to start the chain.

=head3 Root.pm, The Beginning

We'll do this in the Root.pm controller, in
C<GeoCat/lib/GeoCat/Controller/Root.pm>.  The default handler should always be
treated as a "404 Not Found" error, so lets make it do that and create our
handlers in Root.pm:

    # 404 Handler
    sub default : Private {
        my ( $self, $c ) = @_;

        $c->response->status(404);
        $c->response->body( qq|404: Not found!| );
    }

    # Base, the starting point
    sub base : Chained('/') : PathPart('') : CaptureArgs(0) {
    }
    # Root, or "/" as the URI is perceived
    sub root : Chained('base') : PathPart('') : Args(0) {
        $c->response->body('Matched GeoCat::Controller::Root in Root.');
    }

Now these don't actually do anything, just inform Catalyst that there will be
an execution chain with these actions.

=head3 Search.pm

Lets finish the chain by setting up C<GeoCat/lib/GeoCat/Controller/Search.pm>:

    # Anything under /search should bind to this action, and it will always
    # be called
    sub base : Chained('/base') : PathPart('search') : CaptureArgs(0) {
    }

    # What the user gets when they visit "/search" (the root action of Search)
    sub root : Chained('base') : PathPart('') : Args(0) {
        my ( $self, $c ) = @_;
        $c->response->body('Matched GeoCat::Controller::Search in Search.');
    }

=head3 Checking our work

After this, it may be a good idea to fire up GeoCat and make sure the actions
are defined properly.  You should see a section in the debug output that looks
like this:

 $ script/geocat_server.pl 
 [ SNIP ]
 [debug] Loaded Chained actions:
 .-------------------------------------+--------------------------------------.
 | Path Spec                           | Private                              |
 +-------------------------------------+--------------------------------------+
 |                                     | /base (0)                            |
 |                                     | => /root                             |
 | /search                             | /base (0)                            |
 |                                     | -> /search/base (0)                  |
 |                                     | => /search/root                      |
 '-------------------------------------+--------------------------------------'

If you see those definitions, the chains are ready to go (and you can visit
both L<http://localhost:3000/> and L<http://localhost:3000/search> to see the
output, but for now it is pretty boring.

=head2 Creating our templates

GeoCat is a simple application, and as such only has a few templates.  Instead
of pasting them in the writeup, you can fetch them along with the rest of GeoCat
from the Catalyst subversion repository.  Here's the list of templates we'll
use:

=over

=item root.tt

The root action ("/") will automatically point to C<root.tt> as the template
to render.  Catalyst figures this out by the final calling action, which can be 
determined by the C<=&gt;> in the "Private" column of the "Loaded Chained
actions" output above.  In the code, you can simply use C<$c-&gt;action>.

To fetch this template, please look here:

L<http://dev.catalyst.perl.org/repos/Catalyst/trunk/examples/GeoCat/root/root.tt>

=item search/root.tt

The simple template that returns search results.  This is actually a JavaScript
file and not HTML, but that doesn't matter for Template Toolkit nor Catalyst!

To fetch this template, please look here:

L<http://dev.catalyst.perl.org/repos/Catalyst/trunk/examples/GeoCat/root/search/root.tt>

=back


