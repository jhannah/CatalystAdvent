=head1 A Catalyst Carol

Sometimes our Catalyst applications are so large, with such complex
business rules, that we get a little overwhelmed by their myriad
components. Or maybe we concentrate so hard on one portion that we
lose perspective on the big picture. Well, fear not!

The Perl world offers several visualization tools. In today's Advent
Calendar, in the spirit of Dicken's Holiday masterpiece and MVC, we'll
look closer into three of them!

=head2 Ghost...erm...Graph of Model Past

  use SQL::Translator;

  my $translator = SQL::Translator->new(
          from => 'MySQL',
          to   => 'GraphViz',
  ) or die SQL::Translator->error;
  $translator->translate;

If you are using Catalyst with the ever popular DBIx::Class (DBIC) and
would rather fetch database information from the schema modules,
rejoice! Use C<< SQL::Translator::Parser::DBIx::Class >> as the
parser, and pass the loaded schema in the "parser_args" parameter. The
code below shows this and gives the producer some customization via
C<< producer_args >>:

  use SQL::Translator;

  my $schema = MyApp::Schema->connect;
  my $translator = SQL::Translator->new(
      parser        => 'SQL::Translator::Parser::DBIx::Class',
      parser_args   => { package => $schema },
      producer      => 'Diagram',
      producer_args => {
          out_file       => 'schema.png',
          output_type    => 'png',
          title          => 'My Schema',
      },
  ) or die SQL::Translator->error;

  $translator->translate;

You can even go crazy and make a Catalyst action that generates the
diagram of the current project's schema:

  sub schema : Local {
      my ( $self, $c ) = @_;

      my $translator = SQL::Translator->new(
          parser        => 'SQL::Translator::Parser::DBIx::Class',
          data          => $c->model('DB')->schema,
          producer      => 'Diagram',
          producer_args => {
              output_type => 'png',
              title       => 'MyApp Schema',
          },
      ) or die SQL::Translator->error;

      $c->res->content_type('image/png');
      $c->res->body( $translator->translate );

  }


=head2 Graph of Controller Present

  use CatalystX::Dispatcher::AsGraph;
   
  my $graph = CatalystX::Dispatcher::AsGraph->new(
        appname => 'MyApp',
        output  => 1,
  );
  $graph->run;
  
B<Note:> As Khisanth pointed out, this module uses MooseX::Declare and
has no "package" information, so the CPAN indexer won't index it, and
the shell won't find it. Until this is fixed by the author, you'll
need to install using the package's full path (e.g. C<< install
FRANCKC/CatalystX-Dispatcher-AsGraph-0.02.tar.gz >>), or fetch the
tarball directly from the web.

=head2 Graph of Template Future

  use Template::AsGraph;

  my $graph = Template::AsGraph->graph('mytemplate.tt2');

If you need a way to understand how your templates fit together, it
probably means their flow is so intricate that you dynamically load
bits and pieces depending on the data passed in by the
Controller. Don't worry: the C<graph> method can also receive TT
configurations as the second argument, and variables as the third:

  use Template::AsGraph;

  my %config = (
      INCLUDE_PATH => 'root/src/',
      START_TAG    => '<+',
      END_TAG      => '+>',
      PLUGIN_BASE  => 'MyApp::Template::Plugin',
      PRE_PROCESS  => 'header',
  );

  my %vars = (
       foo => 'bar',
       bar => 'baz', 
  );

Alternatively, if you have a Catalyst context object lying around, you
can do like View::TT:
  my %vars = ( %{ $c->stash() }, 
                  c    => $c, 
                  base => $c->req->base, 
                  name => $c->config->{name} 
             );

  my $graph = Template::AsGraph->graph('mytemplate.tt2', \%config, \%vars);


=head2 Authors

Breno G. de Oliveira C<< <garu@cpan.org> >>

Bogdan Lucaciu C<< zamolxes@sinapticode.com >>
